

let val1 = 10;
let val2 = 5;
function addNum(num1,num2){
    let total = num1+num2
    return total;
}

let result1 = addNum(val1,val2)
let result2 = addNum(10,2)




ğŸ”· JavaScript Execution Context Diagram (Step-by-Step)
ğŸ“Œ Code
let val1 = 10;
let val2 = 5;

function addNum(num1, num2) {
    let total = num1 + num2;
    return total;
}

let result1 = addNum(val1, val2);
let result2 = addNum(10, 2);

ğŸ§  Step 1: Global Execution Context (GEC)
Memory Creation Phase
Global Memory:
val1     â†’ uninitialized (TDZ)
val2     â†’ uninitialized (TDZ)
addNum   â†’ function
result1 â†’ uninitialized (TDZ)
result2 â†’ uninitialized (TDZ)

Execution Phase
val1 = 10
val2 = 5

ğŸ“Œ Step 2: First Function Call â†’ addNum(val1, val2)
Function Execution Context (FEC-1)
Memory Phase
num1  â†’ 10
num2  â†’ 5
total â†’ uninitialized

Execution Phase
total = 10 + 5 â†’ 15
return 15

Call Stack at this moment
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ addNum()  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   GEC     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


After return:

result1 = 15

ğŸ“Œ Step 3: Second Function Call â†’ addNum(10, 2)
Function Execution Context (FEC-2)
Memory Phase
num1  â†’ 10
num2  â†’ 2
total â†’ uninitialized

Execution Phase
total = 10 + 2 â†’ 12
return 12

Call Stack
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ addNum()  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   GEC     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


After return:

result2 = 12

âœ… Final Global Values
val1 = 10
val2 = 5
result1 = 15
result2 = 12

ğŸ“ Interview-Ready Explanation (Short)

JavaScript first creates a Global Execution Context.
Memory is allocated for variables and functions.
When a function is called, a new Function Execution Context is created, pushed onto the call stack, executed, and then removed after returning the value.

âš ï¸ Important Notes

let variables stay in Temporal Dead Zone until initialized

Each function call creates a new execution context

Call stack follows LIFO (Last In First Out)